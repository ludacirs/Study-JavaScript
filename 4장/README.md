# 4장. 함수와 프로토타입 체이닝

## 함수

### 1. 함수의 생성

#### 함수를 생성하는 방법 3가지 ([func_const.js]())
1. 함수 선언문

2. 함수 표현식

3.  Function() 생성자 함수

#### 함수 호이스팅 ([func_hoisting.js]())

* 함수 호이스팅 때문에 함수 표현식을 사용한 함수 생성만을 사용할 것을 추천

### 2. 함수 객체 : 함수도 객체다

#### 함수도 객체 ([func_pro.js]())
* 함수도 일반 객체 처럼 프로퍼티를 동적으로 추가하는게 가능하다.

#### 함수는 값으로 취급된다 ([func_obj.js]())
* 자바스크립트에서 함수는 [일급 객체](https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4)로 취급된다.

1. 변수나 프로퍼티의 값으로 할당

2. 함수 인자로 전달

3. 리턴값으로 활용

#### 함수 객체의 기본 프로퍼티

* 함수 객체만의 표준 프로퍼티가 정의
     * 모든 함수는 length와 prototype 프로퍼티를 가짐 (나머지 프로퍼티는 ECMA표준이 아니다.)
     
     * \_\_proto\__ 프로퍼티 즉, 부모를 Function.prototype 객체라고 가르킴
        * Function.prototype 객체는 Empty() 함수로 정의되어 있다
        * Function.prototype는 함수이지만 자기 자신을 부모로 가르키지 않고 예외로 Object.prototype을 부모로 가르킴

1. length 프로퍼티

    함수가 정상적으로 실행될 때 기대되는 인수의 개수를 나타낸다.

2. prototype 프로퍼티
    
    * 객체의 부모를 나타내는 내부 프로퍼티인 \__proto\__와 헷갈리지 않기
    
    * prototype 프로퍼티는 함수 객체가 생성됨과 동시에 constructor 객체를 가르킨다.
        * construct 객체는 자신과 연결된 함수 객체를 가르킨다.
        따라서
                prototype <----> constructor
          와 같은 상태 
          
### 3. 함수의 다양한 형태

1. 콜백 함수 
    * 익명 함수의 대표적인 용도
    * 명시적으로 호출하는 함수가 아니라 이벤트가 발생하면 시스템에서 호출하거나, 함수의 인자로서 코드 내부에서 호출되는 함수
    
2. 즉시 실행 함수 ([func_now.js]())
    * 익명 함수를 정의함과 동시에 실행하는 함수
    * 재사용이 불가능하기 때문에 최초 한 번의 실행만을 필요로 하는 초기화 코드에 활용

3. 내부 함수 ([func_inn.js]())
    * 함수 코드 내부에서 함수를 정의한 함수
    * 함수 내부에서만 사용이 가능하고 외부에서 바로 내부함수로는 접근이 불가능
    * 부모 함수에서 내부 함수를 리턴해주면 외부에서도 접근이 가능 (클로저)

4. 함수를 리턴하는 함수 ([func_redef.js]())
    * 함수를 호출함과 동시에 다른 함수로 바꾸거나 자신을 재 정의하는 함수

### 4. 함수 호출과 this

1. arguments 객체 ([func_arg.js]())
    * 자바스크립트에서는 함수 형식에 맞춰 인자를 넘기지 않아도 에러가 발생하지 않는다
        * 형식보다 적으면 undefined, 많으면 무시되지만 프로퍼티에 반영은 된다.
        
    * arguments 객체에는 인자들(배열), length, callee로 구성
        * 인자들 : 넘겨진 인자들이 배열형태로 저장
        * length : 호출할 때 넘겨진 인자들의 개수
        * callee : 현재 실행중인 함수의 참조값
        
2. 호출 패턴과 this 바인딩 
    * 함수 호출시의 this바인딩 ([func_this.js]())
    
    * 생성자 함수로 객체 생성 ([func_new.js]())
    
    * call과 apply 메서드를 이용한 명시적인 this 바인딩([func_apply.js]())
    
3. 함수 리턴 규칙
    1. 자바스크립트의 함수는 항상 리턴값을 반환한다 (return문을 명시하지 않아도 undefined가 반환)
    
    2. 생성자 함수에서 리턴값을 지정하지 않으면 생성된 객체를 반환한다 ([func_retu.js]())
        * 다른 객체를 리턴하면 생성된 객체가 아닌 return에 있는 객체를 반환
        
### 5. 프로토타입 체이닝

#### 객체 리터럴로 생성된 객체와 생성자 함수로 생성된 객체의 프로토타입 체이닝
* [proto_ch.js]()

* 객체 리터럴
*     foo.[[Prototype]] -> Object.prototype.hasOwnProperty()

* 생성자 함수
*     foo.[[Prototype]] -> Person.prototype.[[Prototype]] -> Object.prototype.hasOwnProperty()

#### 프로토타입 체이닝의 종점 
* 위에서 살펴봤듯이 객체 리터럴, 생성자 함수로 생성된 객체는 프로토타입 체이닝시 마지막에 Object.prototpye으로 도착하게된다.

* 모든 객체가 Object.prototype의 프로퍼티나 메서드를 사용할 수 있다는 것을 의미

#### 프로토타입도 자바스크립트 객체
* 표준 프로토타입에도 동적으로 메서드나 프로퍼티가 추가 가능 ([proto_ext.js]())


#### 프로토타입 메서드와 this 바인딩
* [proto_this.js]()


#### 디폴트 프로토타입은 다른 객체로 변경이 가능하다
* [proto_change.js]()


#### 객체에서 프로퍼티를 읽거나 메서드를 실행할 때만 프로토타입 체이닝이 작동
* [proto_run.js]()
